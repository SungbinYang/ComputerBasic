> 이 강좌는 [널널한 개발자님의 강의](https://www.inflearn.com/course/%EB%84%93%EA%B3%A0%EC%96%95%EA%B2%8C-%EC%BB%B4%EA%B3%B5-%EC%A0%84%EA%B3%B5%EC%9E%90/dashboard)를 기반으로 작성한 글입니다.

## 디지털 회로와 덧셈

### 디지털 회로

디지털 회로를 우리가 왜 배울까? 뭐 면접에도 나오기도 하고 각 종 시험에서 나오기도 하지만 근본적인 이유는 바로 CPU를 제작하기 위해서이다. 여기서 의문이 드는 게 그럼 CPU는 왜 우리가 만들어야 할까? 이미 대기업에서 만들어진 CPU를 잘 사용하면 된다. 하지만 이것이 어떻게 만들어지고 동작이 되는지는 알고 쓰면 더 좋기 때문이며 그게 근간하는 내용이 디지털 회로이다. 아래의 그림은 각 연산 gate들의 진리표이므로 잘 숙지해둬야 한다.

| A   | B   | AND | OR  | XOR | NOT |
| --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 1   |
| 1   | 0   | 0   | 1   | 1   | 0   |
| 0   | 1   | 0   | 1   | 1   |     |
| 1   | 1   | 1   | 1   | 0   |     |

그러면 원래 CPU는 뭐하는 것인가? 간단히 얘기하면 '전자계산기'라고 한다. 여기서 '전자'라는 말이 중요한데 왜 전자를 사용할까? 빛이나 물을 이용할 수는 없을까? 물론 이용이 가능하지만 전자를 사용하는 이유는 빠르기 때문이다. 그럼 어떤 계산기일까? 바로 산수연산에 대한 계산기이다. 즉, CPU를 만들고 싶다고 하면 산수 계산기를 만들면 되고 산수의 기본이 되는 +기능부터 만들면 된다.

> 여기서 잠깐, 위의 표에서 input으로 들어가는 a,b는 하나하나가 1bit라고 할 수 있다.

### 컴퓨터가 덧셈하는 방법

- 2진수 1 + 1은 2진수 10(2) 이다.
- A가 1, B가 1이면 XOR 연 산결과 S는 0이다.
- 동시에 A가 1, B가 1이면 AND 연산결과 C는 1이다. 이 1은 자리 올림(Carry)이다.
- 두 수를 더할 수 있으면 CPU를 만들 수 있다.

위의 그림은 반가산기로 덧셈을 해주는 기계이다. 그것을 논리회로로 표현한 것이다. 하지만 이것은 1bit 한정이며 예를 들어 8bit끼리 덧셈을 하려고 하면 자리올림 또한 생각을 해줘야 하므로 반가산기로는 부족하다. 그래서 나온 회로가 전가산기다. 전가산기는 아래와 같다.

전가산기를 병렬로 이어서 다양한 bit의 계산이 가능하다.

### 수제 CPU

이런 전가산기를 이용하여 수제 CPU를 만든 분이 계신다. 아래 링크를 클릭해서 한번 확인해 보자.

[홈브류 cpu](http://www.homebrewcpu.com/)

> 이 강좌는 [널널한 개발자님의 강의](https://www.inflearn.com/course/%EB%84%93%EA%B3%A0%EC%96%95%EA%B2%8C-%EC%BB%B4%EA%B3%B5-%EC%A0%84%EA%B3%B5%EC%9E%90/dashboard)를 기반으로 작성한 글입니다.

## 컴퓨터가 뺄셈 하는 방법

컴퓨터가 뺄셈을 어떻게 할까? 뺄셈은 보수의 덧셈을 하면 해결이 된다. 그럼 보수는 무엇일까? 예를 들어 6을 10의 보수를 구하라고 한다고 하면 답은 4가 나온다. 즉, 어떤 수를 더해서 n이 되었을 때 어떤 수가 n의 보수가 된다. 즉, 뺄셈은 보수의 덧셈으로 보면 될 것이다.

전에 배웠던 전가산기에 input값을 보수를 넣어주면 된다. 2진수도 비슷하다. 2진수는 1의 보수를 구한 다음에 더하기 1만 해주면 된다.

> 2의 보수 = 1의 보수(not gate) + 1

이렇게 보면 뺄셈도 덧셈의 응용편이다. 그럼 이제 곱셈과 나눗셈이 문제인데 이것도 마찬가지다. 곱셈은 여러 번 덧셈을 하는 것이고 나눗셈은 여러 번 뺄셈을 하는 것이다. 즉, 모든 사칙연산이 덧셈에 근간한 거고 CPU도 사칙 계산기로 덧셈에 근간한다고 볼 수 있다.

> 이 강좌는 [널널한 개발자님의 강의](https://www.inflearn.com/course/%EB%84%93%EA%B3%A0%EC%96%95%EA%B2%8C-%EC%BB%B4%EA%B3%B5-%EC%A0%84%EA%B3%B5%EC%9E%90/dashboard)를 기반으로 작성한 글입니다.

## CPU가 곱하고 나누는 방법

### 컴퓨터가 곱셈하는 방법

곱셈은 여러번 더하기를 진행하면 된다. 하지만, 이 메커니즘은 너무 비효율적이라 shift연산을 이용하여 효율적인 메커니즘을 구축하게 되었다.

곱셈은 left shift연산을 하게 되는데 여기서 shift연산은 어떻게 하는 것일까? 왼쪽 마지막 자리를 기준으로 왼쪽으로 한 칸씩 미루는 행위이다. 그러면 기준자리를 넘어가는 부분은 버리고 오른쪽에 비어지게 되는 자리는 0으로 채워진다(padding). 2진수 기준으로 1칸씩 shift연산은 2씩 곱하는 행위와 같게 된다. 아래는 left shift연산의 예시의 이미지이니, 한번 참고해 보자.

### 컴퓨터가 나눗셈하는 방법

나눗셈도 곱셈과 마찬가지이다. 원래 나눗셈은 여러 번 뺄셈을 진행하면 되었지만 이 또한 비효율적이라 shift연산을 이용하게 되었다.

나눗셈은 right shift연산을 진행한다. right shift연산은 오른쪽 자리를 기준으로 오른쪽으로 한 칸씩 미는 행위이다. 자리를 넘어가는 것은 버리고 왼쪽에 비어지는 자리는 0으로 채운다.(padding)

#### 0으로 나누기

그런데 문득, 이런 생각을 해본 적이 있을 것이다. 만약 어떤 수를 0으로 나누면 어떻게 될까? 예를 들어, 22라는 수를 0으로 나누면 어떻게 될까? 나눗셈은 뺄셈의 연장선이다. 그래서 22에서 0을 뺄 것이다. 그러면 22가 나올 것이고 또 0을 뺄 것이다. 언제까지 뺄까? 더 이상 뺄 수 없을 상태, 즉 무한대로 뺄 것이다. 그러면 CPU는 이를 처리하기 위해 열 에너지가 발생할 것이고 결국 폭발을 할 것이다. 하지만 우리가 사용하는 범용 CPU는 폭발하지 않는다. 그 이유는 예외처리를 해두었기 때문이다. 하지만 ATMEGA128 같은 장치로 이 과정을 수행하면 폭발을 하게 되는데 아래 동영상 링크를 참조할 테니 한번 확인해 보자.

[나눗셈 링크](https://www.youtube.com/watch?v=mZ7pUADoo58)
